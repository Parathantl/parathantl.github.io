{"componentChunkName":"component---src-templates-blog-post-js","path":"/basic-guide-to-closures-in-javascript/","result":{"data":{"site":{"siteMetadata":{"title":"Parathan's blog"}},"markdownRemark":{"id":"9c47a682-45b1-5436-9c4f-5070724677a7","excerpt":"The Closure is a collection of all variables in scope at the time of function creation. To use closure, create a function inside another function which is…","html":"<p>The Closure is a collection of all variables in scope at the time of function creation. To use closure, create a function inside another function which is called a Nested Function. The inner function will have access to the variables in the outer function scope (<strong>Closure</strong> helps to access the outer function scope), even after the outer function has returned. Closures are created every time a function is created.</p>\n<p>Before moving on to understand about Closures, let’s first get the big picture about Scope Chain in JavaScript.</p>\n<p>Normally, there are 2 types of scope:</p>\n<ul>\n<li>Global Scope</li>\n<li>Local Scope</li>\n</ul>\n<p>In ES5 version, a variable inside a function is not visible outside. But variables inside a block (conditions like if or while) are visible outside too.</p>\n<p>From this, ES5 has function scope. There is no block scope.</p>\n<blockquote>\n<p>Edited on: 9th May 2019</p>\n<p>According to <strong>ES5</strong>, using functions were the only way to declare a block scope in code.</p>\n<p>But, in ES6 it was eased by <strong>let</strong> &#x26; <strong>const</strong> keywords which provides block scope.</p>\n<p>Anyhow, Its better to have a knowledge on how JavaScript evolved step by step.</p>\n</blockquote>\n<p>Lets continue this in ES5 version :</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 10;  \nfunction app(){  \n   var b = 2;  \n   console.log(a); // 10  \n   console.log(b); // 2  \n}  \nconsole.log(b); \n// ReferenceError: b is not defined\n\napp();</code></pre></div>\n<p>As we already know, <strong>a</strong> is a Global variable &#x26; <strong>b</strong> is a local variable which is <strong>specific</strong> to the app function.</p>\n<p>We can’t get the value of a local variable out of the local scope.</p>\n<h2>Using a Nested Function — Function inside a Function</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 10;\n\nfunction app(){  \n     var b = 2;  \n     var d = 3; function add(){  \n     var c = a + b;  \n   } return add;  \n}  \n\nvar x = app();  \nconsole.dir(x);</code></pre></div>\n<p>Here, the app is the parent function &#x26; add function is the child function.</p>\n<ul>\n<li>Rather than using console.log, <strong>console.dir</strong> is used to console all the properties of a specified JavaScript object which helps developers get the properties of that object</li>\n<li>Variable x is assigned to app function &#x26; the app function returns the add function. Therefore we could see all the object properties of the add function.</li>\n</ul>\n<p>If you see the console in the browser, you could see the Closure object inside the Scopes array.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/60938c472c53b8dac1841f9a36bafa33/64b22/1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.645569620253163%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3aAH/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAGBABAQADAAAAAAAAAAAAAAAAAQARIVH/2gAIAQEAAT8hEtcsl//aAAwDAQACAAMAAAAQcA//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQGhIWHx/9oACAEBAAE/EJjxQ+Boo//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/60938c472c53b8dac1841f9a36bafa33/828fb/1.jpg\"\n        srcset=\"/static/60938c472c53b8dac1841f9a36bafa33/ff44c/1.jpg 158w,\n/static/60938c472c53b8dac1841f9a36bafa33/a6688/1.jpg 315w,\n/static/60938c472c53b8dac1841f9a36bafa33/828fb/1.jpg 630w,\n/static/60938c472c53b8dac1841f9a36bafa33/0ede0/1.jpg 945w,\n/static/60938c472c53b8dac1841f9a36bafa33/64b22/1.jpg 1199w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Since the inner <strong>function add</strong> accesses the outer function variables <strong>b &#x26; d</strong>, those 2 variables will be added to the Closure object for the reference.</p>\n<p>Let’s have look at the next example for Closure:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var a = 10;  \nvar startFunc;\n\nfunction app(){  \n      var b = 2; \n   function add() {  \n      var c = a + b;  \n      console.log(c);  \n   } \n   startFunc = add();  \n}\n\napp(); \n// Invoke the app functionstartFunc;   \n\n// as the app function invoked above will assign the add function to startFunc &amp; console the value of c</code></pre></div>\n<ul>\n<li>a Global function called startFunc is assigned to the add function which is a child function of the parent app function.</li>\n<li>This is possible only after the app function is invoked, otherwise startFunc will act as a global variable without any value assigned</li>\n</ul>\n<h2>Application of Closures in JavaScript</h2>\n<p>Most of us use Closures while coding but we don’t get why we are using it. JavaScript doesn’t have the access modifiers like <strong>private, public, protected</strong> like other Object Oriented Programming Languages. So, we have to use functions to protect the namespace from the outside code usage in ES5.</p>\n<p>Especially in functions, <strong>Immediately-invoked Function Expression (IIFE)</strong> is the one which is executed immediately after the declaration. You don’t need to invoke the function after the function is declared.</p>\n<p>IIFE enables to write <strong>Module Pattern</strong> (one of the Design Pattern) in JavaScript.</p>\n<p>Syntax definition of IIFE is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">(function() {  \n    //variables &amp; scope that inside the function   \n})();</code></pre></div>\n<p>Let’s have an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var studnetEnrollment = (function () {  \n     //private variables which no one can change  \n     //except the function declared below. \n     var count = 0;  \n     var prefix = &quot;S&quot;; \n     // returning a named function expression  \n     function innerFunc() {  \n         count = count + 1;  \n         return prefix + count;  \n     };\n     return innerFunc;    \n})();\n     \nvar x = studnetEnrollment(); // S1  \nconsole.log(x);\n\nvar y = studnetEnrollment(); // S2   \nconsole.log(y);</code></pre></div>\n<p>count &#x26; prefix are the 2 private variables which can’t be changed by anyone &#x26; can only be accessible to the inner function (here its innerFunc). This access is possible only by the feature called Closure.</p>\n<ul>\n<li>At the first time, when the studentEnrollment function is called, the count variable inside the function is incremented 1 by innerFunc function.</li>\n<li>At the second time, the count is incremented the previous value of count which is 1 to 2</li>\n<li>These are possible by the Closure feature.</li>\n</ul>\n<h2>Conclusion</h2>\n<p>The Closure is a collection of variables in an outer function which gives access to the inner function scope to protect the global namespace.</p>\n<p>Closures enable developers to write clean code like OOP Languages which doesn’t confuse the global &#x26; local variable names in ES5 version.</p>\n<p>Happy Coding…….!!!!!</p>","frontmatter":{"title":"A basic guide to Closures in JavaScript","date":"May 04, 2019","description":null,"tags":["JavaScript"]}}},"pageContext":{"slug":"/basic-guide-to-closures-in-javascript/","previous":{"fields":{"slug":"/how-to-build-a-rest-api-with-spring-boot-using-mysql-and-jpa/"},"frontmatter":{"title":"How to build a Rest API with Spring Boot using MySQL and JPA"}},"next":{"fields":{"slug":"/zero-to-one-in-object-oriented-concepts/"},"frontmatter":{"title":"Zero to One in Object Oriented Concepts"}}}},"staticQueryHashes":["2841359383","2944715102"]}