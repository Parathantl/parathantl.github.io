{"componentChunkName":"component---src-templates-blog-post-js","path":"/design-patterns-zero-to-hero-abstract-factory-pattern/","result":{"data":{"site":{"siteMetadata":{"title":"Parathan's blog"}},"markdownRemark":{"id":"60f8a49d-6efe-5861-a880-c1686349bf4d","excerpt":"The Abstract Factory is called a factory of factories. In the previous article, we have seen the Simple Factory and Factory Method patterns. This patter too…","html":"<p>The Abstract Factory is called a factory of factories. In the previous article, we have seen the Simple Factory and Factory Method patterns. This patter too comes under the Creational Pattern category. This provides one of the best ways to create an object.</p>\n<blockquote>\n<p>Abstract Factory <strong>relies on object composition</strong>. Object creation is implemented in methods exposed in the Factory interface.</p>\n<p><strong>Intent of the Abstract Factory Pattern is to create families of related objects without having to depend on their concrete class.</strong></p>\n</blockquote>\n<h2>Let’s take an example of a scenario to implement this pattern in real-word.</h2>\n<p>I want to implement a system for the Cloth showroom where Men and Women wares sold. To get particular people wares we have come up with Abstract Factory Pattern where it uses interface/abstract classes to hide the concrete classes and wrap up all those into an Abstract Factory class.</p>\n<p>While execution this Abstract Factory class chooses which sub-class Factory class has to be executed and gives the output.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c9c8414f07c30325131f3dafd887b341/898f6/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.12658227848101%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABlElEQVQoz11Si3KCMBDk/z/Oaa0K1EjCQx5JeATCSw12JbU63RmYcLd3u3fBuT0xDEPbtnVdK6X6vl+WpdM6iqIgCBijOBuzgDZf5nEcbYmDxxhzvV6lkIfDfvOx2e13qGmaJs8Lz/O+v30hZc65KKs0y8mJnIIAGlprB2Wox7vrurIsheDQl1JCvyxlksRZlkGqblTbacSLItcrpmly/mxDH6QkSfphgG3khid6rcdhmOfZrHhIrZIv26ptKaVwDmNQANUy0CuKI9/3Xc9ljMHRo/7fzEIIQsjpRMIwpIyO04QgUnCByJEcEQSKorjf769ii8uKbgXGxvxYGw76DZbzUr4+Yd4Abyxkn9st7gm9rLvfgW925NfMuNTlLWogGIYYkJ3Tc93U7zVmZduIM88XTAWTUMBidd/bq8InthDQAEPaWwUNb5yrugITjRwpS0oD/Biox1XBcJqmruuiBtSqqjjnhBztb4d2nufudl/YHOodzos4jkGFGtJKNWEU5nkuOFeqRRarRlaIR1ZIYclQQusfw02k2DSWvXsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"1\"\n        title=\"1\"\n        src=\"/static/c9c8414f07c30325131f3dafd887b341/f058b/1.png\"\n        srcset=\"/static/c9c8414f07c30325131f3dafd887b341/c26ae/1.png 158w,\n/static/c9c8414f07c30325131f3dafd887b341/6bdcf/1.png 315w,\n/static/c9c8414f07c30325131f3dafd887b341/f058b/1.png 630w,\n/static/c9c8414f07c30325131f3dafd887b341/898f6/1.png 798w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><strong>MaterialType Interface</strong>: Through this interface, all the type of cloth class will be implemented. This can be an interface or an abstract class. If you define abstract you declare and define variables for the sub-classes who extend.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public interface MaterialType {  \n   void getName();  \n}</code></pre></div>\n<p><strong>LongSleeveTop</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class LongSleeveTop implements MaterialType {  \n   @Override  \n   public void getName() {  \n      System.out.println(&quot;Long Sleeve Top for Woman&quot;);  \n   }  \n}</code></pre></div>\n<p><strong>Scarf class</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Scarf implements MaterialType {  \n   @Override  \n   public void getName() {  \n      System.out.println(&quot;Scarf for Woman&quot;);  \n   }  \n}</code></pre></div>\n<p><strong>MenShirt Class</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class MenShirt implements MaterialType {  \n   @Override  \n   public void getName() {  \n      System.out.println(&quot;Shirt for Men&quot;);  \n   }  \n}</code></pre></div>\n<p><strong>AbstractFactory:</strong> Acts as an Abstract Factory to choose which sub-class factory to execute during the run-time</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public abstract class AbstractFactory {  \n   abstract Shape getMaterialType(String mateType) ;  \n}</code></pre></div>\n<p><strong>MenWearFactory:</strong> Chooses which concrete classes of MaterialType interface to be executed at run-time for men related material types.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class MenWearFactory extends AbstractFactory {@Override  \n   public Shape getMaterialType(String mateType){      \n      if(mateType.equalsIgnoreCase(&quot;MenShirt&quot;)){  \n         return new MenShirt();           \n      }else if(mateType.equalsIgnoreCase(&quot;MenTrouser&quot;)){  \n         return new MenTrouser();  \n      }\t   \n      return null;  \n   }}</code></pre></div>\n<p><strong>WomenWearFactory:</strong> Selects which concrete class to be executed for Women related MaterialType classes.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class WomenWearFactory extends AbstractFactory {\n\t@Override  \n\tpublic Shape getMaterialType(String mateType){      \n\t\tif(mateType.equalsIgnoreCase(&quot;Scarf&quot;)){  \n\t\t\treturn new Scarf();           \n\t\t}else if(mateType.equalsIgnoreCase(&quot;LongSleeveTop&quot;)){  \n\t\t\treturn new LongSleeveTop();  \n\t\t}\t   \n\t\treturn null;  \n\t}\n}</code></pre></div>\n<p><strong>FactoryProducer:</strong> Selects which Factory to be executed according to the parameter passed from the Client code</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class FactoryProducer { \n\tpublic static AbstractFactory getFactory(boolean men){     \n\t\tif(men){  \n\t\t\treturn new MenWearFactory();           \n\t\t}else{  \n\t\t\treturn new WomenWearFactory();  \n\t\t}  \n\t}\n}</code></pre></div>\n<p><strong>Client class: (Main Program)</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">public class Client { \n\tpublic static void main(String[] args) { \n\t\t//get MenWear factory  \n\t\tAbstractFactory menFactory = FactoryProducer.getFactory(false); \n\t\t\n\t\t//get an object of MaterialType Men Shirt  \n\t\tMaterialType cl1 = menFactory.getMaterialType(&quot;MenShirt&quot;); \n\n\t\t//call getName method of MaterialType MenShirt  \n\t\tcl1.getName(); \n\t\t\n\t\t//get an object of MaterialType Trousers  \n\t\tMaterialType cl2 = menFactory.getMaterialType(&quot;Trousers&quot;); \n\n\t\t//call getName method of MaterialType Trousers  \n\t\tcl2.getName(); \n\t\t\n\t\t//get WomenWearFactory  \n\t\tAbstractFactory womenFactory = FactoryProducer.getFactory(true); \n\t\t\n\t\t//get an object of Shape Rectangle  \n\t\tMaterialType cl3= womenFactory.getMaterialType(&quot;Scarf&quot;); \n\n\t\t//call getName method of MaterialType Scarf  \n\t\tcl3.getName(); \n\t}\n}</code></pre></div>\n<p>By implementing the abstract factory we <strong>reduce the coupling between classes by using abstract/interfaces and extending/implementing those base classes by concrete classes.</strong></p>\n<p>The concrete classes here are MenShirt, Scarf, LongSleeveTop, and Trouser. So, what we have done is creating interfaces and abstractions to hide all these implemented classes and just let the program to choose which class to be executed at the run-time.</p>\n<p>I hope you enjoyed this.</p>","frontmatter":{"title":"Design Patterns — Zero to Hero — Abstract Factory Pattern","date":"July 01, 2020","description":null,"tags":["Design Patterns"]}}},"pageContext":{"slug":"/design-patterns-zero-to-hero-abstract-factory-pattern/","previous":{"fields":{"slug":"/design-patterns-zero-to-hero-factory-pattern-simple-factory-and-factory-method/"},"frontmatter":{"title":"Design Patterns — Zero to Hero — Factory Pattern (Simple Factory and Factory Method)"}},"next":{"fields":{"slug":"/design-patterns-zero-to-hero-decorator-pattern/"},"frontmatter":{"title":"Design Patterns — Zero to Hero — Decorator Pattern"}}}},"staticQueryHashes":["2841359383","2944715102"]}